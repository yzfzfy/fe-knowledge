# 递归

递归==>循环

因为函数调用的开销，递归常常会带来性能问题，特别是在求解规模不确定的情况下；而循环因为没有函数调用开销，所以效率会比递归高。递归求解方式和循环求解方式往往可以互换，也就是说，如果用到递归的地方可以很方便使用循环替换，而不影响程序的阅读，那么替换成循环往往是好的。

问题的递归实现转换成非递归实现一般需要两步工作： (1). 自己建立“堆栈(一些局部变量)”来保存这些内容以便代替系统栈，比如树的三种非递归遍历方式；

递归的三要素
//1、明确递归终止条件；
//2、给出递归终止时的处理办法；
//3、提取重复的逻辑，缩小问题规模。

// 阶乘的实现

```jsx
// 递归实现
function Factorial(n) {
    if (n === 1) {
        // 递归终止条件
        return 1; // 简单情景
    }

    return n * Factorial(n - 1); // 相同重复逻辑，缩小问题的规模
}
// 非递归实现
function F_loop(n) {
    let res = n; //局部变量

    while (n > 1) {
        n--;
        res = n * res;
    }

    return res;
}
```

// 斐波那契数列

```jsx
function fibonacci(n) {
    if (n === 1 || n === 2) {
        // 递归终止条件
        return 1; // 简单情景
    }

    return fibonacci(n - 1) + fibonacci(n - 2); // 相同重复逻辑，缩小问题的规模
}
```

// 上台阶 一次只能跨一阶或两阶，问题：上 n 阶的台阶一共有多少种上方法

```jsx
function step(n) {
    if (n === 1) {
        return 1;
    }

    if (n === 2) {
        return 2;
    }
    return step(n - 1) + step(n - 2);
}
```

# 相关链接

-   [递归](https://juejin.cn/post/7023313758378262542)
