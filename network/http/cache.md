# http 缓存

http 缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。
使用 http 缓存，可以减少客户端等待时间和网络流量，同时也能缓解服务器端的压力。显著提升我们网站和应用的性能。所以只是作为一个性能优化的手段，并不是必须的。

## http 缓存的类型

-   强缓存 强制使用缓存
-   协商缓存 这里的协商是指需要和服务端核实是否使用缓存

### 强缓存

强缓存不会向服务器发送请求，而是直接从缓存中读取资源，在 chrome 控制台 network 面板中可以看到有的请求 status 返回是 200，但是有的请求 size 一栏显示 from disk cache 或 from memory cache。

### 协商缓存

协商缓存会向服务器发送一个请求，服务器会根据这个请求的 request header 的一些参数来判断是否命中协商缓存，如果命中，则返回 304 状态码并带上新的 response header 通知浏览器从缓存中读取资源。

## 缓存控制

在 HTTP 中，我们可以通过设置响应头以及请求头来控制缓存策略。

强缓存可以通过设置 Expires 和 Cache-Control 两种响应头实现。如果同时存在，Cache-Control 优先级高于 Expires。

### Expires

expires 响应头，代表资源的过期时间，其实为一个绝对时间。用于告诉浏览器在过期时间之前可以直接从浏览器缓存中读取数据。由于是个绝对时间，客户端与服务端的时差或误差等因素可能造成客户端与服务端时间不一致，将导致缓存命中的误差。如果在 cache-control 响应头设置了 max-age 指令。那么 expires 会被忽略。

> Expires: Wed, 21 Oct 2015 07:28:00 GMT

### Cache-Control

cache-control 可以指定多个指令来实现缓存机制。主要用于表示资源缓存的最大有效时间。即在该时间段内，客户端不需要向服务端发送请求。优先级高于 expires。其过期时间指令的值是相对时间，他解决了绝对时间带来的问题。

> Cache-Control: max-age=315360000

Cache-Control 有很多属性，不同的属性代表的意义也不同。

#### 可缓存性

-   public 表明响应可以被任何对象（包括发送请求的客户端、代理服务器等）缓存。
-   private 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）
-   no-cache 不适用强缓存，需要与服务器校验协商缓存验证
-   no-store 缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。

#### 过期

-   max-age=seconds 缓存存储的最大周期，超过这个周期被认为过期
-   s-maxage=<seconds> 设置共享缓存。会覆盖 max-age 和 expires,私有缓存会忽略它
-   max-stale[=<seconds>] 客户端愿意接收一个已经过期的资源，可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。
-   min-fresh=seconds 客户端希望在指定的时间内获取最新的响应。

#### 重新验证和重新加载

-   must-revalidate 如页面过期，则去服务器进行获取。
-   proxy-revalidate 与 must-revalidate 作用相同，但是用于共享缓存。

#### 其他

-   only-if-cached 不进行网络请求，完全只使用缓存。
-   no-transform 不得对资源进行转换和转变。例如，不得对图像格式进行转换。

协商缓存可以通过 last-modified/if-modified-since 和 etag/if-none-match 这两对 header 字段来控制。

### Last-Modified、If-Modified-Since

两个值都是 GMT 格式的时间字符串，代表的是文件的最后修改时间。

1. 在服务器响应请求时，会通过 last-modified 告诉浏览器资源的最后修改时间。
2. 浏览器再次请求服务器时，请求头会包含 If-Modified-Since 字段，值是上次请求时服务器返回的修改时间，该值存储在缓存中。
3. 服务端收到请求头发现有 if-modified-since，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 状态码和响应报文头，浏览器只需要从缓存中获取信息即可。如果已经修改，那么开始传输响应一个整体，服务器返回 200 ok

但是服务器上经常会出现一种情况，一个资源被修改了，其实际内容根本没有发生改变，会因为 last-modified 时间匹配不上而返回整个实体给客户端，为了解决这个问题，http/1.1 推出了 etag。优先级要高于 last-modified

### etag、if-not-match

etag 是服务器为每份资源生成的唯一标识，就像一个指纹，资源变化会导致 etag 变化，跟最后修改时间无关，etag 可以保证每一份资源是唯一的。

在浏览器发起请求，浏览器的请求报头会包含 if-none-match 字段，其值为上次返回的 etag。服务器接收到报文后发现 if-none-match 则与被请求资源的唯一标识进行对比，如果相同说明资源没有修改，则响应返回 304，浏览器直接从缓存中获取数据信息。如果不同则说明资源被改动过，则响应整个资源内容，返回 200 状态码。

## 总结

通过前文，我们了解到 HTTP 缓存主要分：

-   强制缓存
-   协商缓存。

强制缓存由 Cache-Control，Exipres（HTTP1.0）控制。浏览器直接读本地缓存，不会再跟服务器端交互，状态码 200。
协商缓存由 Last-Modified / IfModified-Since， Etag /If-None-Match 实现，每次请求需要让服务器判断一下资源是否更新过，从而决定浏览器是否使用缓存，如果是，则返回 304，否则重新完整响应。
