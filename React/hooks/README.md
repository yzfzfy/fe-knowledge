# hooks 函数式编程

## 优点

1 逻辑复用。class 组件间逻辑无法复用，自定义 hook 可以实现
2 代码量少。不用写那么多的生命周期 this bind 可以不写了。
3 相关的逻辑可以放在一起，好理解。mount 和 unmount 逻辑代码在一起，class 中在两个生命周期中，逻辑分离。

## 缺点

1 工作方式理解有负担，不完全理解很可能会有副作用等意想不到的问题
2 优点的第三点可能也是缺点 不易理解
3 旧的引用问题
4 hooks 变多时 依赖项改变后执行很乱

## 理念的不同

个人认为我们在写类组件时，通过调用函数，从而触发状态改变、ui 刷新，这个过程是命令式的。而在 hooks 中，在非类比生命周期阶段我们依然可以通过主动触发事件来刷新状态、主动执行其他函数，但是使用到 effect 时，他的理念完全不同，我们可以监听一个状态，因这个状态引起的 ui 更新交由 effect 负责，而我们只需要更新 effect 依赖的状态即可。其实就是将改变状态和因状态改变引起的其他效果隔离开来，这样有利于逻辑抽离与复用。也就是优点的第一点。

### 业务举例：

class 组件一般使用逻辑如下：
按钮事件触发 => 回调执行更改某个状态，如果当前事件还需要执行其他副作用那么同步调用另一个函数 => 执行 render

但是在使用 hooks 时，个人通常会这么使用：
按钮事件触发 => 回调执行改变状态 => 有一个 effect 监听了这个状态，那么会执行 => effect 执行后可能更改了另一个状态 => 执行 render

上述过程可以看出两种方式在第二步中的区别，在 hooks 中将一步分为了两步执行。

**hooks 的 effect 设计思想就是监听一个依赖，视图刷新依靠于状态的改变。这样我们就可能构建出一个依赖的链，一个 effect 执行更改了另一个 effect 的依赖的值，然后执行下一个 effect。effect 就像一个 watch 函数或者一个开关，控制着副作用执行。**

### 再回头看 class 和 hook 的思想可以在对方的基础上实现吗？

其实是可以的。

比如在 class 中实现 effect 的监听思想：

在事件回调函数中改变第一个状态，然后在 componentDidUpdate 中比较 prevState 与 this.state 的值。不同时，执行副作用函数。会发现用类组件实现就相当于 effect 监听的值对应于 didupdate 中的一个 if。

在 effect 中实现 class 的 didupdate 逻辑。

其实也就是 dom 上绑定一个事件就应该改变一个状态，由这个状态引起的后续副作用都在监听这个状态的 effect 中处理。
