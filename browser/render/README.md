# 从输入 URL 到页面呈现发生了什么？

> https://www.baidu.com/

## 网络

1. 构造请求行

```js
// 请求方法是GET，路径为根路径，HTTP协议版本为1.1
GET / HTTP / 1.1;
```

2. 查找强缓存

先查找强缓存，如果命中直接使用，否则进入下一步。

3. DNS 解析

如果没有命中强缓存，则会发出请求。由于输入的是域名，而数据包是通过 IP 地址传给对方的。因此需要通过域名得到它对应的 IP 地址。这个过程需要依赖一个服务系统，做映射，这就是 DNS（域名系统）。因此得到具体 IP 的过程就是 DNS 解析。

当然，值得注意的是，浏览器提供了**DNS 数据缓存功能**。如果一个域名已经解析过，那会把解析的结果缓存下来，下次就不需要经过 DNS 解析过程，直接走缓存。
另外，如果不指定端口的话，默认采用对应 IP 的 80 端口。

4. 建立 TCP 连接

chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接，超过 6 个的话剩下的请求就需要等待。

> TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

建立 TCP 连接经历了下面三个阶段:

-   通过三次握手(即总共发送 3 个数据包确认已经建立连接)建立客户端和服务器之间的连接。
-   进行数据传输。这里有一个重要的机制，就是接收方接收到数据包后必须要向发送方确认, 如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。当然，发送的过程中还有一个优化策略，就是把大的数据包拆成一个个小包，依次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。
-   断开连接的阶段。数据传输完成，现在要断开连接了，通过四次挥手来断开连接。

### 三次握手

三次握手的目的是为了确保双方的接收和发送能力是否正常，只有都正常才算建立连接成功。

第一次握手：客户端发送网络包，服务端收到了。

这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。

这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

第三次握手：客户端发包，服务端收到了。

这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。

如果是用两次握手，则会出现下面这种情况：
如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。三次握手不会浪费资源的核心在于只有客户端再次发出也就是服务端再次收到，服务端才会将自己状态置为 ESTABLISHED 状态。三次握手如果出现在某些网络结点长时间滞留，服务端也不会处于 ESTABLISHED 状态。

5. 发送 HTTP 请求

现在 TCP 连接建立完毕，浏览器可以和服务器开始通信，即开始发送 HTTP 请求。浏览器发 HTTP 请求要携带三洋东西：请求行、请求头、请求体。

首先，浏览器会向服务器发送请求行，第一步已构建完毕。
同时还有请求头，比如 Cache-Control、If-Modified-Since、If-None-Match 都有可能被放入请求头中作为缓存的标识信息。当然了还有一些其他属性，

```
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cache-Control: no-cache
Connection: keep-alive
Cookie: /* 省略cookie信息 */
Host: www.baidu.com
Pragma: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1
```

最后是请求体，请求体只有在 POST 方法下存在，常见的场景是表单提交。 6. 请求响应

HTTP 请求到达服务器，服务器进行对应处理。最后要把数据传给浏览器，也就是返回网络响应。
与请求部分类似，也由三个部分：响应行、响应头、响应体。
响应行如：HTTP/1.1 200 ok
由 HTTP 协议版本、状态码和状态描述组成
响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的 Cookie 信息。
如

```
Cache-Control: no-cache
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
Date: Wed, 04 Dec 2019 12:29:13 GMT
Server: apache
Set-Cookie: rsv_i=f9a0SIItKqzv7kqgAAgphbGyRts3RwTg%2FLyU3Y5Eh5LwyfOOrAsvdezbay0QqkDqFZ0DfQXby4wXKT8Au8O7ZT9UuMsBq2k; path=/; domain=.baidu.com
```

响应完成之后怎么办？TCP 连接就断开了吗？
不一定。这时候要判断 Connection 字段, 如果请求头或响应头中包含 Connection: Keep-Alive，表示建立了持久连接，这样 TCP 连接会一直保持，之后请求统一站点的资源会复用这个连接。
否则断开 TCP 连接, 请求-响应流程结束。

## 网络响应的处理

完成了网络请求和响应，如果响应头中 Content-Type 的值是 text/html，那么接下来就是浏览器的解析和渲染工作了。这里输入的网址返回的是百度的页面 html 内容。

首先是解析，它包括三个步骤

-   构建 DOM 树
-   样式计算
-   生成布局树（Layout Tree）

1. 构建 DOM 树

由于浏览器无法直接理解 HTML 字符串，因此将这一系列字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是 DOM 树。DOM 树本质上是一个以 document 为根节点的多叉树。解析 html 文本，通过标签的<>识别节点，生成 dom 节点对象，最终构造为一个大的 DOM 树。 2. 样式计算

样式来源一般有三种。link 标签引用、style 标签中的样式、元素的内嵌 style 属性。
与 dom 树类似，浏览器也是无法直接识别 css 样式文本的，因此渲染引擎收到 css 文本之后也需要将其转化为一个结构化的对象，即 stylSheets。在浏览器控制台能够通过 document.styleSheets 来查看这个最终的结构。然后计算每个节点的具体样式，计算有两个规则：继承和层叠。每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫 UserAgent 样式。这就是继承规则，非常容易理解。然后是层叠规则，CSS 最大的特点在于它的层叠性，也就是最终的样式取决于各个属性共同作用的效果。

计算完样式之后，所有的样式可以通过 window.getComputedStyle()获取对应节点样式。

3. 生成布局树

现在已经生成了 DOM 树和 DOM 样式，接下来要做的就是通过浏览器的布局系统确定元素的位置，也就是要生成一棵布局树(Layout Tree)。
布局树生成的大致工作如下:

-   遍历生成的 DOM 树节点，并把他们添加到布局树中。
-   计算布局树节点的坐标位置。

值得注意的是，这棵布局树值包含可见元素，对于 head 标签和设置了 display: none 的元素，将不会被放入其中。

## 渲染

[来源](https://github.com/sanyuan0704/my_blog/blob/master/blogs/browser/browser-render/003.md)
大致分为一下几个步骤

-   建立图层树(Layer Tree)
-   生成绘制列表
-   生成图块并栅格化
-   显示器显示内容

### 建图层树

有布局树之后还不能开始绘制页面，有一些场景比如 3D 动画如何呈现出变换效果，当元素含有层叠上下文时如何控制显示和隐藏等等。为了解决如上所述的问题，浏览器在构建完布局树之后，还会对特定的节点进行分层，构建一棵图层树(Layer Tree)。构造图层树有两种方式。显式合成和隐式合成。

### 生成绘制列表

渲染引擎会将图层的绘制分成一个个绘制指令。比如先画北京再画边框，然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。

### 生成图块和生成位图

### 显示器显示内容

合成线程生成绘制命令后，发给浏览器进程，浏览器进程会把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。
